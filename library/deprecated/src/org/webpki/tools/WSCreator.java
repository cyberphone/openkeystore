/*
 *  Copyright 2006-2021 WebPKI.org (http://webpki.org).
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */
package org.webpki.tools;

import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.TreeSet;

import java.io.FileOutputStream;
import java.io.File;
import java.io.IOException;

import org.webpki.util.ArrayUtil;

import org.webpki.xml.DOMAttributeReaderHelper;
import org.webpki.xml.DOMReaderHelper;
import org.webpki.xml.DOMWriterHelper;
import org.webpki.xml.XMLObjectWrapper;
import org.webpki.xml.XMLSchemaCache;

/**
 * From an XML description file create Web Services artifacts.
 */
public class WSCreator extends XMLObjectWrapper {
    static final String JCLIENT = "jclient";
    static final String JSERVER = "jserver";
    static final String WSDL = "wsdl";
    static final String DOTNETCLIENT = "dotnetclient";
    static final String CPPCLIENT = "cppclient";
    static final String DOTNETDOC = "dotnetdoc";

    static final String VERSION = "1.0";

    static String GENERATED = "Generated by " + WSCreator.class.getSimpleName() + " " + VERSION + " - Do not edit!";
    static String HEADER = "#########################################################";
    static boolean jclient;
    static boolean jserver;
    static boolean wsdl_gen;
    static boolean dotnet_gen;
    static boolean cpp_gen;
    static boolean dotnet_doc;

    static String output_directory;

    FileOutputStream wsdl_file;
    FileOutputStream dotnetdoc_file;

    int position;

    String license_text;

    LinkedHashMap<String, Constant> global_client_constants;


    String getLicense(boolean jdoc) {
        if (license_text == null) return "";
        StringBuilder out = new StringBuilder();
        int i = 0;
        boolean first = true;
        StringBuilder res = new StringBuilder();
        while (i < license_text.length()) {
            char c = license_text.charAt(i++);
            if (c == '\r') continue;
            res.append(c);
            if (c == '\n') {
                if (jdoc) {
                    out.append(first ? "/*" : " *");
                    first = false;
                }
                out.append(res);
                res = new StringBuilder();
            }
        }
        if (jdoc) {
            out.append(" */\n");
        }
        return out.toString();
    }

    void genSlashes(FileOutputStream file) throws IOException {
        write(file, "        ");
        for (int i = -6; i < GENERATED.length(); i++) {
            write(file, "/");
        }
        write(file, "\n");
    }

    void writeGenerate(FileOutputStream file) throws IOException {
        genSlashes(file);
        writeln(file, "        // " + GENERATED + " //");
        genSlashes(file);
    }

    abstract class Package {
        FileOutputStream jfile;
        String class_name;
        String class_header = "";
        String package_name;
        String path;
        boolean next;
        String jserver_support_code = "";

        abstract String decoration();

        abstract String class_interface();

        abstract boolean is_server();

        Package(DOMReaderHelper rd, String elem, WSCreator owner, boolean dot_net) throws IOException {
            rd.getNext(elem);
            String canonicalized_class_name = attr.getString("ClassName");
            boolean path_as_directory = attr.getBooleanConditional("PathAsDirectory", true);
            dot_net_partial = attr.getBooleanConditional("Partial", true);
            dot_net_registry_url = attr.getStringConditional("RegistryURL");
            dot_net_default_url = attr.getStringConditional("DefaultURL");

            String[] imports = attr.getListConditional("Imports");
            if (jserver && is_server()) {
                if (imports != null) {
                    for (String string : imports) {
                        owner.addImport(string);
                    }
                }
                if (add_main = attr.getBooleanConditional("AddMain")) {
                    owner.addImport("javax.xml.ws.Endpoint");
                }
            } else if (imports != null && dot_net) {
                for (String string : imports) {
                    dotnet_imports.add(string);
                }
            }
            class_name = canonicalized_class_name;
            path = output_directory;
            int i = canonicalized_class_name.lastIndexOf('.');
            if (i > 0) {
                class_name = canonicalized_class_name.substring(i + 1);
                package_name = canonicalized_class_name.substring(0, i);
                if (path_as_directory) {
                    path += File.separatorChar;
                    for (int j = 0; j < i; j++) {
                        path += canonicalized_class_name.charAt(j) == '.' ? File.separatorChar : canonicalized_class_name.charAt(j);
                    }
                }
            }
            rd.getChild();
            if (rd.hasNext("ClassHeader")) {
                class_header = rd.getString("ClassHeader");
            }
            if (rd.hasNext("SupportCode")) {
                jserver_support_code = rd.getString("SupportCode");
            }
            if (dot_net) while (rd.hasNext("RewriteRule")) {
                rd.getNext();
                String rule = attr.getString("Name");
                if (dotnet_rewrite_rules.put(rule, new RewriteRule(attr.getString("ActualType"),
                        attr.getString("Conversion"))) != null) {
                    bad("Duplicate rewrite rule: " + rule);
                }
            }
            if (dot_net) while (rd.hasNext("SuppressRule")) {
                String code = rd.getString();
                String rule = attr.getString("Name");
                if (dotnet_suppress_rules.put(rule, new SuppressRule(code)) != null) {
                    bad("Duplicate suppress rule: " + rule);
                }
            }
            if (dot_net) while (rd.hasNext("EmbedRule")) {
                rd.getNext();
                String rule = attr.getString("Name");
                String before = null;
                String after = null;
                rd.getChild();
                if (rd.hasNext("Before")) {
                    before = rd.getString();
                }
                if (rd.hasNext("After")) {
                    after = rd.getString();
                }
                rd.getParent();
                if (dotnet_embed_rules.put(rule, new EmbedRule(before, after)) != null) {
                    bad("Duplicate suppress rule: " + rule);
                }
            }
            rd.getParent();
        }

        public void writePackage() throws IOException {
            write(jfile, getLicense(true));
            if (package_name != null) {
                writeln(jfile, "package " + package_name + ";");
            }
            write(jfile, "\n");
            writeGenerate(jfile);
        }

        public void writeImports() throws IOException {
            String last_import_pack = "";
            for (String impstr : dotnet_gen ? dotnet_imports : jimports) {
                int i = impstr.lastIndexOf('.');
                if (i < 0) i = impstr.length();
                if (!last_import_pack.equals(impstr.substring(0, i))) {
                    write(jfile, "\n");
                    last_import_pack = impstr.substring(0, i);
                }
                writeln(jfile, (dotnet_gen ? "    using " : "import ") + impstr + ";");
            }
        }
    }

    class ServerPack extends Package {
        ServerPack(DOMReaderHelper rd, WSCreator parent) throws IOException {
            super(rd, "JavaServer", parent, false);
        }

        @Override
        String decoration() {
            return ",\n" +
                    "            name=\"" + service_name + ".Interface\",\n" +
                    "            portName=\"" + service_name + ".Port\",\n" +
                    "            wsdlLocation=\"" + wsdl_location + "\"";
        }

        @Override
        String class_interface() {
            return "class";
        }

        @Override
        boolean is_server() {
            return true;
        }

    }

    class ClientPack extends Package {
        ClientPack(DOMReaderHelper rd, boolean dot_net, WSCreator parent) throws IOException {
            super(rd, dot_net ? "DotNetClient" : "JavaClient", parent, dot_net);
        }

        @Override
        String decoration() {
            return "";
        }

        @Override
        String class_interface() {
            return "interface";
        }

        public void openAddedClass(String class_name) throws IOException {
            jimports.clear();
            jfile = new FileOutputStream(path + File.separatorChar + class_name + ".java");
            writePackage();
        }

        @Override
        boolean is_server() {
            return false;
        }

    }

    class CppPackage {
        FileOutputStream jfile;
        String class_name;
        String class_header = "";
        String package_name;
        String path;
        String cpp_registry_url;
        String cpp_default_url;
        boolean next;

        CppPackage(DOMReaderHelper rd) throws IOException {
            path = output_directory;
            rd.getNext();
            class_name = attr.getString("ClassName");
            cpp_registry_url = attr.getStringConditional("RegistryURL");
            cpp_default_url = attr.getStringConditional("DefaultURL");

        }

        public void writePackage() throws IOException {
            write(jfile, getLicense(true));
            if (package_name != null) {
                writeln(jfile, "package " + package_name + ";");
            }
            write(jfile, "\n");
            writeGenerate(jfile);
        }
    }

    ServerPack jserver_pck;

    ClientPack jclient_pck;

    ClientPack dotnet_client_pck;

    CppPackage cpp_client_pck;

    TreeSet<String> jimports = new TreeSet<>();

    TreeSet<String> dotnet_imports = new TreeSet<>();

    DOMAttributeReaderHelper attr;

    String tns;

    boolean qualified_ns;

    String wsdl_location;

    String sub_target_ns;

    String service_name;

    String default_url;

    static class DataType {
        boolean nullable;
        String xsd_name;
        String enum_name;
        String csname;
        String jname;
        String jholder;

        DataType(boolean nullable, String xsd_name, String enum_name, String csname, String jname, String jholder) {
            this.nullable = nullable;
            this.xsd_name = xsd_name;
            this.enum_name = enum_name;
            this.csname = csname;
            this.jname = jname;
            this.jholder = jholder;
        }

    }

    static ArrayList<DataType> types = new ArrayList<>();

    static {
        //                       NULL    WSDL               DESC       C#        Java       Holder
        types.add(new DataType(false, "xs:int", "int", "int", "int", "Integer"));
        types.add(new DataType(false, "xs:short", "short", "short", "short", "Short"));
        types.add(new DataType(false, "xs:byte", "byte", "sbyte", "byte", "Byte"));
        types.add(new DataType(false, "xs:boolean", "bool", "bool", "boolean", "Boolean"));
        types.add(new DataType(true, "xs:string", "string", "string", "String", "String"));
        types.add(new DataType(true, "xs:base64Binary", "binary", "byte[]", "byte[]", "byte[]"));
    }

    DataType getDataType(String descr_type) throws IOException {
        DataType data_type = null;
        for (DataType dtype : types) {
            if (dtype.enum_name.equals(descr_type)) {
                data_type = dtype;
                break;
            }
        }
        if (data_type == null) {
            bad("Type '" + descr_type + "' not found");
        }
        return data_type;
    }

    class Property extends Container {
        DataType data_type;

        boolean nullable;

        boolean listtype;

        RewriteRule dotnet_rewrite_rule;

        SuppressRule dotnet_suppress_rule;

        boolean input_mode;

        boolean output_mode;

        String jName(boolean object_type) {
            return object_type || listtype ? (listtype ? "List<" + data_type.jholder + ">" : data_type.jholder) : data_type.jname;
        }

        String nType() {
            return listtype ? "List<" + data_type.csname + ">" : data_type.csname;
        }

        String nName(boolean external) {
            if (external) {
                StringBuilder s = new StringBuilder();
                boolean upperit = true;
                for (int i = 0; i < name.length(); i++) {
                    char c = (upperit ? name.toUpperCase() : name).charAt(i);
                    if (c == '_') {
                        upperit = true;
                    } else {
                        upperit = false;
                        s.append(c);
                    }
                }
                if (s.toString().toLowerCase().indexOf(getXMLName().toLowerCase()) == 0) {
                    s = new StringBuilder(getXMLName()).append(s.toString().substring(getXMLName().length()));
                }
                return s.toString();
            }
            return name;
        }

        String nRealType() {
            return (dotnet_rewrite_rule == null ? nType() : dotnet_rewrite_rule.simple_type) +
                    ((listtype && dotnet_rewrite_rule != null) ? "[]" : "");
        }

        String nRealTypeName() {
            return nRealType() + " " + nName(true);
        }

        public String nArgument(String prefix, boolean request) {
            String arg = prefix + nName(request);
            if (dotnet_rewrite_rule != null) {
                String sub = arg;
                arg = dotnet_rewrite_rule.conversion;
                int i = 0;
                while (i < arg.length()) {
                    if (arg.charAt(i++) == '$') {
                        arg = arg.substring(0, i - 1) + sub + arg.substring(i);
                    }
                }
            }
            return arg;
        }

        public String nPrefix() {
            return output_mode ? (input_mode ? "ref " : "out ") : "";
        }
    }

    abstract class Container {
        String name;
        String xml_name;

        public String getXMLName() {
            return xml_name == null ? name : xml_name;
        }

    }

    class Method extends Container {
        String[] execptions;

        Property return_prop;

        String code;

        ReturnClass return_class;

        EmbedRule dotnet_embed_rule;

        boolean public_method;

        public String getXMLResponseName() {
            return getXMLName() + ".Response";
        }

        Collection<Property> parameters;

        public String dotNetReturnClass() {
            return return_class == null ? null : return_class.class_name;
        }

        public void writeNetTypedList(boolean actual) throws IOException {
            StringBuilder spaces = new StringBuilder(",\n");
            for (int i = 0; i < position; i++) {
                spaces.append(' ');
            }
            boolean next = false;
            for (Property prop : (actual && return_class == null) ? parameters : filteredParameters(false)) {
                if (actual && prop.dotnet_suppress_rule != null) continue;
                if (next) {
                    write(dotnet_client_pck.jfile, spaces.toString());
                } else {
                    next = true;
                }
                write(dotnet_client_pck.jfile, prop.nPrefix() + (actual ? prop.nRealTypeName() : prop.nType() + " " + prop.nName(true)));
            }
        }

        public String getNetWrapper(boolean request) {
            return request || return_class == null ?
                    (name + (request ? "_Request" : "_Response")) : dotNetReturnClass();
        }

        public Collection<Property> filteredParameters(boolean output) {
            Collection<Property> props = new ArrayList<>();
            if (output && return_prop != null) {
                props.add(return_prop);
            }
            for (Property prop : parameters) {
                if (output ? prop.output_mode : prop.input_mode) {
                    props.add(prop);
                }
            }
            return props;
        }
    }

    class Constant {
        DataType type;
        String value;
    }

    class EnumerationClass {
        LinkedHashMap<String, String> entries = new LinkedHashMap<>();
        DataType type;
        String class_name;
    }

    class WSException extends Container {
        Collection<Property> getPropsMinusMessage() {
            Collection<Property> filtered = new ArrayList<>();
            boolean next = false;
            for (Property prop : properties) {
                if (next) {
                    filtered.add(prop);
                }
                next = true;
            }
            return filtered;
        }

        String getName() {
            return jclient ? name + "_Exception" : name;
        }

        String getBeanName() {
            return name + "Bean";
        }

        Collection<Property> properties;

        LinkedHashMap<String, Constant> constants;
    }

    class RewriteRule {
        RewriteRule(String full_path, String conversion) {
            int i = full_path.lastIndexOf('.');
            this.conversion = conversion;
            simple_type = full_path;
            if (i > 0) {
                using_declaration = full_path.substring(0, i);
                simple_type = full_path.substring(i + 1);
                dotnet_imports.add(using_declaration);
            }
        }

        String using_declaration;
        String simple_type;
        String conversion;
    }

    class SuppressRule {
        SuppressRule(String header_code) {
            this.header_code = header_code;
        }

        String header_code;
    }

    class EmbedRule {
        EmbedRule(String before, String after) {
            this.before = before;
            this.after = after;
        }

        String before;
        String after;
    }

    class ReturnClass {
        String class_name;

        String null_value;  // May be null

        boolean has_null_constructor;

        LinkedHashMap<String, Constant> constants;
    }

    LinkedHashMap<String, WSException> exceptions = new LinkedHashMap<>();
    ArrayList<Method> methods = new ArrayList<>();
    LinkedHashMap<String, RewriteRule> dotnet_rewrite_rules = new LinkedHashMap<>();
    LinkedHashMap<String, SuppressRule> dotnet_suppress_rules = new LinkedHashMap<>();
    LinkedHashMap<String, EmbedRule> dotnet_embed_rules = new LinkedHashMap<>();
    LinkedHashMap<String, ReturnClass> return_classes = new LinkedHashMap<>();
    LinkedHashMap<String, EnumerationClass> enumerations = new LinkedHashMap<>();
    boolean add_main;
    String dot_net_registry_url;
    String dot_net_default_url;
    boolean dot_net_partial;

    @Override
    protected boolean hasQualifiedElements() {
        return true;
    }

    @Override
    protected void init() throws IOException {
        addSchema("wscreator.xsd");
    }

    @Override
    protected void fromXML(DOMReaderHelper rd) throws IOException {
        attr = rd.getAttributeHelper();
        if (wsdl_gen) {
            wsdl_file = new FileOutputStream(output_directory);
        }
        tns = attr.getString("NameSpace");
        default_url = attr.getString("DefaultURL");
        service_name = attr.getString("Service");
        qualified_ns = attr.getBoolean("Qualified");
        wsdl_location = attr.getString("WSDLLocation");
        sub_target_ns = qualified_ns ? "\", targetNamespace=\"" + tns + "\"" : "\"";

        rd.getChild();

        addImport("javax.jws.WebMethod");
        addImport("javax.jws.WebService");

        addImport("javax.xml.ws.RequestWrapper");
        addImport("javax.xml.ws.ResponseWrapper");

        if (rd.hasNext("LicenseHeader")) {
            license_text = rd.getString("LicenseHeader");
        }

        if (rd.hasNext("GlobalClientConstants")) {
            rd.getNext();
            rd.getChild();
            global_client_constants = getConstants(rd);
            rd.getParent();
        }

        write(wsdl_file, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<!--\n" + getLicense(false) + "\n");
        writeGenerate(wsdl_file);
        write(wsdl_file, "\n-->\n" + "<wsdl:definitions targetNamespace=\"" + tns + "\"\n" +
                "                  xmlns:wsdl=\"http://schemas.xmlsoap.org/wsdl/\"\n" +
                "                  xmlns:tns=\"" + tns + "\"\n" +
                "                  xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n" +
                "                  xmlns:soap=\"http://schemas.xmlsoap.org/wsdl/soap/\">\n\n" +
                "  <wsdl:types>\n\n" +
                "    <xs:schema targetNamespace=\"" + tns + "\"\n" +
                "               elementFormDefault=\"" + (qualified_ns ? "qualified" : "unqualified") + "\" attributeFormDefault=\"unqualified\">\n");

        if (rd.hasNext("JavaServer")) {
            jserver_pck = new ServerPack(rd, this);
            if (jserver) {
                open(jserver_pck, true);
            }
        } else if (jserver) {
            bad("The '" + JSERVER + "' option requires a \"JavaServer\" definition!");
        }
        if (rd.hasNext("JavaClient")) {
            jclient_pck = new ClientPack(rd, false, this);
            if (jclient) {
                open(jclient_pck, true);
            }
        } else if (jclient) {
            bad("The '" + JCLIENT + "' option requires a \"JavaClient\" definition!");
        }
        if (rd.hasNext("DotNetClient")) {
            dotnet_client_pck = new ClientPack(rd, true, this);
            dotnet_imports.add("System.Collections.Generic");
            if (dotnet_gen) {
                open(dotnet_client_pck, false);
            } else if (dotnet_doc) {
                dotnetdoc_file = new FileOutputStream(output_directory);
            }
        } else if (dotnet_gen || dotnet_doc) {
            bad("The '" + DOTNETCLIENT + "' and '" + DOTNETDOC + "' options require a \"DotNetClient\" definition!");
        }
        if (rd.hasNext("CppClient")) {
            cpp_client_pck = new CppPackage(rd);
            if (cpp_gen) {
                open(cpp_client_pck, false);
            }
        } else if (cpp_gen) {
            bad("The '" + CPPCLIENT + "' option requires a \"CppClient\" definition!");
        }
        while (rd.hasNext("Exception")) {
            rd.getNext();
            WSException exception = new WSException();
            exception.name = attr.getString("ClassName");
            exception.xml_name = attr.getStringConditional("XMLName");
            rd.getChild();
            exception.properties = getProperties(rd, "Property");
            Property first = null;
            for (Property prop : exception.properties) {
                if (first == null) {
                    first = prop;
                }
                if (!prop.name.equals(prop.name.toLowerCase())) {
                    bad("JAX-WS requires that all exception properties are lowercase:" + prop.name);
                }
            }
            if (!first.name.equals("message")) {
                bad("Exceptions must have a first attribute \"message\"");
            }
            if (!first.nType().equals("string")) {
                bad("\"message\" must be a \"string\"");
            }
            exception.constants = getConstants(rd);
            rd.getParent();
            exceptions.put(exception.name, exception);
        }
        while (rd.hasNext("Enumeration")) {
            rd.getNext();
            EnumerationClass enumeration = new EnumerationClass();
            enumeration.class_name = attr.getString("ClassName");
            enumeration.type = getDataType(attr.getString("Type"));
            rd.getChild();
            while (rd.hasNext("Entry")) {
                rd.getNext();
                enumeration.entries.put(attr.getString("Name"), attr.getString("Value"));
            }
            rd.getParent();
            if (enumerations.put(enumeration.class_name, enumeration) != null) {
                bad("Duplicate enum" + enumeration.class_name);
            }
        }
        while (rd.hasNext("ReturnClass")) {
            rd.getNext();
            ReturnClass return_class = new ReturnClass();
            return_class.class_name = attr.getString("ClassName");
            return_class.null_value = attr.getStringConditional("NullValue");
            return_class.has_null_constructor = attr.getBooleanConditional("NullConstructor");
            rd.getChild();
            return_class.constants = getConstants(rd);
            rd.getParent();
            return_classes.put(return_class.class_name, return_class);
        }
        do {
            rd.getNext("Method");
            Method method = new Method();
            method.name = attr.getString("Name");
            method.xml_name = attr.getStringConditional("XMLName");
            String return_class = attr.getStringConditional("ReturnClass");
            if (return_class != null) {
                if ((method.return_class = return_classes.get(return_class)) == null) {
                    bad("Return class '" + return_class + "' missing");
                }
            }
            String embed_rule = attr.getStringConditional("EmbedRule");
            if (embed_rule != null) {
                if ((method.dotnet_embed_rule = dotnet_embed_rules.get(embed_rule)) == null) {
                    bad("Embed rule '" + embed_rule + "' missing");
                }
            }
            method.public_method = attr.getBoolean("Public");
            method.execptions = attr.getListConditional("Throws");
            if (method.execptions == null) method.execptions = new String[0];
            rd.getChild();
            method.return_prop = getPropertyConditional(rd, "Returns");
            method.parameters = getProperties(rd, "Parameter");
            if (method.return_prop != null) {
                addImport("javax.jws.WebResult");
            }
            for (Property prop : method.parameters) {
                addImport("javax.jws.WebParam");
                if (prop.output_mode) {
                    addImport("javax.xml.ws.Holder");
                }
            }
            String code = rd.getStringConditional("Code");
            method.code = jserver ? "\n      {" + (code == null ? "\n" : code) + "      }" : ";";
            rd.getParent();
            for (String exception : method.execptions) {
                if (!exceptions.containsKey(exception)) {
                    bad("Exception '" + exception + "' missing declaration");
                }
            }
            methods.add(method);
        }
        while (rd.hasNext("Method"));

        for (WSException exception : exceptions.values()) {
            write(wsdl_file, "\n");
            writeWSDLProperties(exception.getXMLName(), exception.properties, qualified_ns);
        }

        for (Method meth : methods) {
            StringBuilder method_name = new StringBuilder();
            int lspace = (HEADER.length() - meth.name.length() - 2) / 2;
            while (lspace-- > 0) method_name.append(' ');
            method_name.append(meth.name);
            while (method_name.length() < (HEADER.length() - 2)) {
                method_name.append(' ');
            }
            write(wsdl_file, "\n<!--\n      " + HEADER + "\n" +
                    "      #" + method_name + "#\n" +
                    "      " + HEADER + "\n-->\n");
            writeWSDLProperties(meth.getXMLName(), meth.filteredParameters(false), false);
            writeWSDLProperties(meth.getXMLResponseName(), meth.filteredParameters(true), false);
        }

        write(wsdl_file, "\n    </xs:schema>\n\n  </wsdl:types>\n");

        for (WSException exception : exceptions.values()) {
            write(wsdl_file, "\n" + "  <wsdl:message name=\"" + exception.getXMLName() + "\">\n" + "    <wsdl:part name=\"fault\" element=\"tns:" + exception.getXMLName() + "\"/>\n" + "  </wsdl:message>\n");
        }

        for (Method meth : methods) {
            write(wsdl_file, "\n" +
                    "  <wsdl:message name=\"" + meth.getXMLName() + "\">\n" +
                    "    <wsdl:part name=\"parameters\" element=\"tns:" + meth.getXMLName() + "\"/>\n" +
                    "  </wsdl:message>\n\n" +
                    "  <wsdl:message name=\"" + meth.getXMLResponseName() + "\">\n" +
                    "    <wsdl:part name=\"parameters\" element=\"tns:" + meth.getXMLResponseName() + "\"/>\n" +
                    "  </wsdl:message>\n");
        }

        write(wsdl_file, "\n  <wsdl:portType name=\"" + service_name + ".Interface\">\n");

        for (Method meth : methods) {
            write(wsdl_file, "\n" +
                    "    <wsdl:operation name=\"" + meth.getXMLName() + "\">\n" +
                    "      <wsdl:input message=\"tns:" + meth.getXMLName() + "\"/>\n" +
                    "      <wsdl:output message=\"tns:" + meth.getXMLResponseName() + "\"/>\n");
            for (String exception : meth.execptions) {
                String xml_name = exceptions.get(exception).getXMLName();
                write(wsdl_file, "      <wsdl:fault message=\"tns:" + xml_name + "\" name=\"" + xml_name + "\"/>\n");
            }
            write(wsdl_file, "    </wsdl:operation>\n");
        }

        write(wsdl_file, "\n  </wsdl:portType>\n\n" +
                "  <wsdl:binding name=\"" + service_name + ".Binding\" type=\"tns:" + service_name + ".Interface\">\n" +
                "    <soap:binding style=\"document\" transport=\"http://schemas.xmlsoap.org/soap/http\"/>\n");

        javaHeader(jserver_pck);
        javaHeader(jclient_pck);

        for (Method meth : methods) {
            javaMethod(jserver_pck, meth);
            javaMethod(jclient_pck, meth);
            write(wsdl_file, "\n" +
                    "      <wsdl:operation name=\"" + meth.getXMLName() + "\">\n" +
                    "        <wsdl:input>\n" +
                    "          <soap:body use=\"literal\"/>\n" +
                    "        </wsdl:input>\n" +
                    "        <wsdl:output>\n" +
                    "          <soap:body use=\"literal\"/>\n" +
                    "        </wsdl:output>\n");
            for (String exception : meth.execptions) {
                String xml_name = exceptions.get(exception).getXMLName();
                write(wsdl_file, "        <wsdl:fault name=\"" + xml_name + "\">\n" + "          <soap:fault name=\"" + xml_name + "\" use=\"literal\"/>\n" + "        </wsdl:fault>\n");
            }
            write(wsdl_file, "      </wsdl:operation>\n");
        }

        write(wsdl_file, "\n    </wsdl:binding>\n\n" +
                "  <wsdl:service name=\"" + service_name + "\">\n" +
                "     <wsdl:port name=\"" + service_name + ".Port\" binding=\"tns:" + service_name + ".Binding\">\n" +
                "       <soap:address location=\"" + default_url + "\"/>\n" +
                "     </wsdl:port>\n" +
                "  </wsdl:service>\n\n" + "</wsdl:definitions>\n");
        close(wsdl_file);
        javaTerminate(jserver_pck);
        javaTerminate(jclient_pck);
        if (jclient) {
            jclient_pck.openAddedClass(service_name);
            addImport("javax.xml.ws.WebServiceClient");
            addImport("javax.xml.ws.WebEndpoint");
            addImport("javax.xml.ws.Service");
            addImport("javax.xml.namespace.QName");
            jclient_pck.writeImports();
            writeln(jclient_pck.jfile, "\n" +
                    "@WebServiceClient(name=\"" + service_name + "\",\n" +
                    "                  targetNamespace=\"" + tns + "\")\n" +
                    "public class " + service_name + " extends Service\n" +
                    "  {\n" +
                    "    public " + service_name + " ()\n" +
                    "      {\n" +
                    "        super (" + service_name + ".class.getResource (\"/" + wsdl_location + "\"),\n" +
                    "               new QName (\"" + tns + "\", \"" + service_name + "\"));\n" +
                    "      }\n" +
                    "\n" +
                    "    @WebEndpoint(name=\"" + service_name + ".Port\")\n" +
                    "    public " + jclient_pck.class_name + " get" + service_name + "Port ()\n" +
                    "      {\n" +
                    "        return super.getPort (new QName (\"" + tns + "\", \"" + service_name + ".Port\"),\n" +
                    "                              " + jclient_pck.class_name + ".class);\n" +
                    "      }\n" +
                    "  }");
            close(jclient_pck);
            for (WSException wse : exceptions.values()) {
                jclient_pck.openAddedClass(wse.getBeanName());
                addImport("javax.xml.bind.annotation.XmlAccessType");
                addImport("javax.xml.bind.annotation.XmlAccessorType");
                addImport("javax.xml.bind.annotation.XmlElement");
                addImport("javax.xml.bind.annotation.XmlType");
                for (Property prop : wse.properties) {
                    if (prop.listtype) {
                        addImport("java.util.List");
                    }
                }
                jclient_pck.writeImports();
                write(jclient_pck.jfile, "\n" + "@XmlAccessorType(XmlAccessType.NONE)\n" + "@XmlType(propOrder={");
                boolean next = false;
                for (Property prop : wse.properties) {
                    if (next) {
                        write(jclient_pck.jfile, ",\n                    ");
                    } else {
                        next = true;
                    }
                    write(jclient_pck.jfile, "\"" + prop.name + "\"");
                }
                writeln(jclient_pck.jfile, "})\npublic class " + wse.getBeanName() + "\n  {");
                next = false;
                for (Property prop : wse.properties) {
                    if (next) write(jclient_pck.jfile, "\n");
                    next = true;
                    writeln(jclient_pck.jfile, "    @XmlElement(required=" + (!prop.nullable) + ", name=\"" + prop.getXMLName() + "\", namespace=\"\")\n    " + prop.jName(false) + " " + prop.name + ";");
                }
                for (Property prop : wse.properties) {
                    if (next) write(jclient_pck.jfile, "\n");
                    next = true;
                    String methn = prop.name;
                    writeln(jclient_pck.jfile, "    public " + prop.jName(false) + " get" + methn.substring(0, 1).toUpperCase() + methn.substring(1) + " ()\n      {\n        return " + prop.name + ";\n      }");
                }
                writeln(jclient_pck.jfile, "  }");
                close(jclient_pck);
                jclient_pck.openAddedClass(wse.getName());
                addImport("javax.xml.ws.WebFault");
                jclient_pck.writeImports();
                write(jclient_pck.jfile, "\n" + "@SuppressWarnings(\"serial\")\n" + "@WebFault(name=\"" + wse.getXMLName() + "\",\n" + "          targetNamespace=\"" + tns + "\")\n" + "public class " + wse.getName() + " extends Exception\n" + "  {\n" + "    /**\n" + "     * Java type that goes as soapenv:Fault detail element.\n" + "     */\n" + "    private " + wse.getBeanName() + " faultInfo;\n" + "\n" + "    /**\n" + "     * @param message\n" + "     * @param faultInfo\n" + "     */\n" + "    public " + wse.getName() + " (String message, " + wse.getBeanName() + " faultInfo)\n" + "      {\n" + "         super (message);\n" + "         this.faultInfo = faultInfo;\n" + "      }\n" + "\n" + "    /**\n" + "     * @param message\n" + "     * @param faultInfo\n" + "     * @param cause\n" + "     */\n" + "    public " + wse.getName() + " (String message, " + wse.getBeanName() + " faultInfo, Throwable cause)\n" + "      {\n" + "        super (message, cause);\n" + "        this.faultInfo = faultInfo;\n" + "      }\n" + "\n" + "    /**\n" + "     * @return fault bean\n" + "     */\n" + "    public " + wse.getBeanName() + " getFaultInfo ()\n" + "      {\n" + "        return faultInfo;\n" + "      }\n" + "  }\n");

                close(jclient_pck);
            }
        }
        if (dotnet_client_pck != null) {
            writeDotNet();
        }
        if (cpp_client_pck != null) {
            writeCpp();
        }
        if (dotnetdoc_file != null) {
            writeDocNetDoc();
        }
    }

    LinkedHashMap<String, Constant> getConstants(DOMReaderHelper rd) throws IOException {
        LinkedHashMap<String, Constant> constants = new LinkedHashMap<>();
        while (rd.hasNext("Constant")) {
            rd.getNext();
            Constant constant = new Constant();
            String name = attr.getString("Name");
            constant.type = getDataType(attr.getString("Type"));
            constant.value = attr.getString("Value");
            constants.put(name, constant);
        }
        return constants;
    }

    void writeCpp() throws IOException {
        writeOneCpp(cpp_client_pck, false);
        if (cpp_gen) open(cpp_client_pck, true);
        writeOneCpp(cpp_client_pck, true);
    }

    void writeOneCpp(CppPackage pck, boolean body) throws IOException {
        write(pck.jfile, body ? "body" : "header");
        if (cpp_gen) close(pck.jfile);
    }

    void writeDocNetDoc() throws IOException {
        write(dotnetdoc_file, "<html><body><table cellpadding=\"20\" border=\"0\">");
        for (Method meth : methods) {
            if (!meth.public_method) {
                continue;
            }
            List<String> null_types = new ArrayList<>();
            write(dotnetdoc_file, "<tr><td>&nbsp;</td></tr><tr><td style=\"border-width:1px 1px 1px 1px;border-style:solid;border-color:black\"><table cellpadding=\"0\" cellspacing=\"0\" border=\"0\">" +
                    "<tr><td><code>" + dotnetReserved("public") + "&nbsp;");
            if (meth.return_class == null) {
                if (meth.return_prop == null) {
                    write(dotnetdoc_file, dotnetReserved("void"));
                } else {
                    write(dotnetdoc_file, dotnetType(meth.return_prop));
                }
            } else {
                write(dotnetdoc_file, meth.return_class.class_name);
            }
            if (meth.return_prop != null && meth.return_prop.nullable && !meth.return_prop.listtype) {
                null_types.add("return&nbsp;value");
            }
            write(dotnetdoc_file, "&nbsp;" + meth.name + "&nbsp;(</code></td><td><code>");
            boolean next = false;
            String null_comment = "";
            for (Property prop : meth.parameters) {
                if (prop.dotnet_suppress_rule != null) continue;
                if (prop.output_mode && meth.return_class != null) {
                    break;
                }
                if (next) {
                    write(dotnetdoc_file, ",</code></td><td><code>" + null_comment + "</code></td></tr><tr><td>&nbsp;</td><td><code>");
                    null_comment = "";
                }
                next = true;
                if (prop.nullable && !prop.listtype) {
                    null_comment = "&nbsp;<font color=\"grey\">// May be null</font>";
                }
                write(dotnetdoc_file, dotnetReserved(prop.nPrefix()) + dotnetType(prop) + "&nbsp;" + prop.nName(true));
            }
            write(dotnetdoc_file, ")</code></td><td><code>" + null_comment + "</code></td></tr>");
            if (meth.execptions.length > 0 || null_types.size() > 0) {
                write(dotnetdoc_file, "<tr><td colspan=\"3\">&nbsp;</td></tr>");
                if (null_types.size() > 0) {
                    write(dotnetdoc_file, "<tr><td colspan=\"3\">May&nbsp;be&nbsp;null:&nbsp;<code>");
                    next = false;
                    for (String name : null_types) {
                        if (next) {
                            write(dotnetdoc_file, ",&nbsp;");
                        }
                        next = true;
                        write(dotnetdoc_file, name);
                    }
                    write(dotnetdoc_file, "</code></td></tr>");
                }
                if (meth.execptions.length > 0) {
                    write(dotnetdoc_file, "<tr><td colspan=\"2\">Throws:&nbsp;<code>");
                    next = false;
                    for (String ex : meth.execptions) {
                        if (next) {
                            write(dotnetdoc_file, ",&nbsp;");
                        }
                        next = true;
                        write(dotnetdoc_file, ex);
                    }
                    write(dotnetdoc_file, "</code></td></tr>");
                }
            }
            write(dotnetdoc_file, "</table></td></tr>");
        }
        write(dotnetdoc_file, "</table></body></html>");
        close(dotnetdoc_file);
    }

    String dotnetType(Property prop) {
        String ret_type = prop.nRealType();
        int i = ret_type.indexOf('[');
        String last = "";
        if (i > 0) {
            last = ret_type.substring(i);
            ret_type = ret_type.substring(0, i);
        }
        return (ret_type.equals(ret_type.toLowerCase()) ? dotnetReserved(ret_type) : "<font color=\"green\">" + ret_type + "</font>") + last;
    }

    String dotnetReserved(String string) {
        return "<font color=\"blue\">" + string + "</font>";
    }

    void writeNetWrapper(boolean request, Method meth) throws IOException {
        Collection<Property> props = meth.filteredParameters(!request);
        FileOutputStream file = dotnet_client_pck.jfile;
        String class_name = meth.getNetWrapper(request);

        write(file, "\n" +
                "    [System.Diagnostics.DebuggerStepThroughAttribute()]\n" +
                "    [System.ServiceModel.MessageContractAttribute(WrapperName=\"" + (request ? meth.getXMLName() : meth.getXMLResponseName()) + "\", WrapperNamespace=\"" + tns + "\", IsWrapped=true)]\n" +
                "    public class " + class_name + "\n" +
                "    {\n");
        int order = 0;
        String warn = request ? "" : "        #pragma warning disable 0649\n";
        String warnoff = request ? "" : "        #pragma warning restore 0649\n";
        for (Property prop : props) {
            if (order != 0) {
                write(file, "\n");
            }
            write(file, "        [System.ServiceModel.MessageBodyMemberAttribute(Namespace=\"" + tns + "\", Order=" + (order++) + ")]\n" +
                    "        [System.Xml.Serialization.XmlElementAttribute(ElementName=\"" + prop.getXMLName() + "\", Form=System.Xml.Schema.XmlSchemaForm." + (qualified_ns ? "Q" : "Unq") + "ualified)]\n" +
                    warn +
                    "        internal " + prop.nType() + " _" + prop.nName(false) + ";\n" +
                    warnoff);
        }

        if (request) {
            if (!props.isEmpty()) {
                write(file, "\n        public " + class_name + "(");
                meth.writeNetTypedList(false);
                write(file, ")\n        {\n");
                for (Property prop : props) {
                    write(file, "            _" + prop.nName(false) + " = " + prop.nName(true) + ";\n");
                }
                write(file, "        }\n");
            }
        } else if (meth.return_class != null) {
            if (!meth.return_class.has_null_constructor) {
                write(file, "\n" +
                        "        internal " + class_name + " () {}\n");
            }
            writeDotNetConstants(file, meth.return_class.constants);
            for (Property prop : props) {
                write(file, "\n" +
                        "        public " + prop.nRealTypeName() + "\n" +
                        "        {\n" +
                        "            get { return " + prop.nArgument("_", false) + "; }\n" +
                        "        }\n");
            }
        }

        write(file, "    }\n");
    }

    void writeDotNet() throws IOException {
        FileOutputStream file = dotnet_client_pck.jfile;
        writeln(file, getLicense(true) + "namespace " + dotnet_client_pck.package_name + "\n{\n");
        writeGenerate(file);
        dotnet_client_pck.writeImports();
        write(file, "\n" + dotnet_client_pck.class_header +
                "    [System.ServiceModel.ServiceContractAttribute(Namespace=\"" + tns + "\")]\n" +
                "    public interface " + dotnet_client_pck.class_name + "Interface\n" +
                "    {\n");
        boolean next = false;
        for (Method meth : methods) {
            if (next) {
                write(file, "\n");
            } else {
                next = true;
            }
            write(file, "        [System.ServiceModel.OperationContractAttribute(Action=\"\", ReplyAction=\"*\")]\n");
            for (String ex : meth.execptions) {
                writeln(file, "        [System.ServiceModel.FaultContractAttribute(typeof(_" + exceptions.get(ex).getName() + "), Action=\"\", Name=\"" + exceptions.get(ex).getName() + "\")]");
            }
            write(file, "        [System.ServiceModel.XmlSerializerFormatAttribute()]\n" + "        " + meth.getNetWrapper(false) + " " + meth.name + "(" + meth.getNetWrapper(true) + " request);\n");
        }
        write(file, "    }\n");

        // WS Exception
        for (String ex : exceptions.keySet()) {
            WSException wse = exceptions.get(ex);
            write(file, "\n" +
                    "    [System.Diagnostics.DebuggerStepThroughAttribute()]\n" +
                    "    public class _" + wse.getName() + " : System.Xml.Serialization.IXmlSerializable\n" +
                    "    {\n" +
                    "        private System.Xml.XmlNode[] nodes;\n\n" +
                    "        public System.Xml.Schema.XmlSchema GetSchema()\n" +
                    "        {\n" +
                    "            return null;\n" +
                    "        }\n\n" +
                    "        public void ReadXml(System.Xml.XmlReader reader)\n" +
                    "        {\n" +
                    "            nodes = System.Runtime.Serialization.XmlSerializableServices.ReadNodes(reader);\n" +
                    "        }\n\n" +
                    "        public void WriteXml(System.Xml.XmlWriter writer)\n" +
                    "        {\n" +
                    "            System.Runtime.Serialization.XmlSerializableServices.WriteNodes(writer, nodes);\n" +
                    "        }\n");
            int index = 0;
            for (Property prop : wse.getPropsMinusMessage()) {
                String value = "nodes[" + (index++) + "].InnerXml";
                if (!prop.nType().equals("string")) {
                    value = "System.Int32.Parse(" + value + ")";
                }
                writeln(file, "\n" +
                        "        internal " + prop.nRealTypeName() + "\n" +
                        "        {\n" +
                        "            get { return " + value + "; }\n" +
                        "        }");
            }
            write(file, "    }\n");
        }

        // The rethrown real exceptions
        for (String ex : exceptions.keySet()) {
            WSException wse = exceptions.get(ex);
            write(file, "\n" +
                    "    [System.Diagnostics.DebuggerStepThroughAttribute()]\n" +
                    "    public class " + wse.getName() + " : System.Exception\n" +
                    "    {\n" +
                    "        public " + wse.getName() + " (");
            next = false;
            for (Property prop : wse.properties) {
                if (next) {
                    write(file, ", ");
                }
                next = true;
                write(file, prop.nRealTypeName());
            }
            write(file, ") : base(message)\n" +
                    "        {\n");
            for (Property prop : wse.getPropsMinusMessage()) {
                write(file, "            this." + prop.name + " = " + prop.name + ";\n");
            }
            write(file,
                    "        }\n\n" +
                            "        public " + wse.getName() + " (System.ServiceModel.FaultException<_" + wse.getName() + "> e) : base(e.Message, e)\n" +
                            "        {\n");
            for (Property prop : wse.getPropsMinusMessage()) {
                write(file, "            this." + prop.name + " = e.Detail." + prop.name + ";\n");
            }
            write(file,
                    "        }\n");
            writeDotNetConstants(file, wse.constants);

            for (Property prop : wse.getPropsMinusMessage()) {
                String prop_name = prop.name.substring(0, 1).toUpperCase() + prop.name.substring(1);
                writeln(file, "\n" +
                        "        private " + prop.nType() + " " + prop.name + ";\n\n" +
                        "        public " + prop.nType() + " " + prop_name + "\n" +
                        "        {\n" +
                        "            get { return " + prop.name + "; }\n" +
                        "        }");
            }
            write(file, "    }\n");
        }

        for (String ex : enumerations.keySet()) {
            EnumerationClass enum_class = enumerations.get(ex);
            write(file, "\n" +
                    "    public enum " + enum_class.class_name + " : " + enum_class.type.csname + "\n" +
                    "    {\n");
            next = false;
            for (String key : enum_class.entries.keySet()) {
                if (next) {
                    write(file, ",\n");
                }
                next = true;
                write(file, "        " + key + " = " + enum_class.entries.get(key));
            }
            write(file, "\n    }\n");
        }

        for (Method meth : methods) {
            writeNetWrapper(true, meth);
            writeNetWrapper(false, meth);
        }
        write(file, "\n" +
                "    public " + (dot_net_partial ? "partial " : "") + "class " + dotnet_client_pck.class_name + " : System.ServiceModel.ClientBase<" + dotnet_client_pck.class_name + "Interface>\n" +
                "    {");

        writeDotNetConstants(file, global_client_constants);

        write(file, "\n" +
                "        public static " + dotnet_client_pck.class_name + " getDefault" + dotnet_client_pck.class_name + "()\n" +
                "        {\n" +
                "            ");
        if (dot_net_registry_url == null && dot_net_default_url == null) {
            write(file, "throw new System.ArgumentException(\"Default proxy not configured in WS definition input file!\");\n");
        } else {
            if (dot_net_registry_url != null) {
                int i = dot_net_registry_url.lastIndexOf('\\');
                if (i <= 0) bad("Bad RegistryURL definition");

                write(file, "Microsoft.Win32.RegistryKey reg_entry = Microsoft.Win32.RegistryKey.OpenBaseKey(Microsoft.Win32.RegistryHive.LocalMachine,\n" +
                        "                                                                        System.Environment.Is64BitOperatingSystem ?\n" +
                        "                                                                          Microsoft.Win32.RegistryView.Registry64 : Microsoft.Win32.RegistryView.Registry32)\n" +
                        "                .OpenSubKey(@\"" + dot_net_registry_url.substring(0, i) + "\");\n" +
                        "            string ws_url = reg_entry == null ? null : (string) reg_entry.GetValue (\"" + dot_net_registry_url.substring(i + 1) + "\");\n" +
                        "            if (ws_url == null)\n" +
                        "            {\n" +
                        "                 ");
                if (dot_net_default_url == null) {
                    write(file, "throw new System.ArgumentException(@\"No such registry entry: " + dot_net_registry_url + "\")");
                } else {
                    write(file, "ws_url = \"" + dot_net_default_url + "\"");
                }
                write(file, ";\n" +
                        "            }\n" +
                        "            ");
            }
            write(file,
                    "System.ServiceModel.BasicHttpBinding ws_bind = new System.ServiceModel.BasicHttpBinding();\n" +
                            "            ws_bind.SendTimeout = System.TimeSpan.FromMinutes(5);\n" +
                            "            return new " + dotnet_client_pck.class_name +
                            "(ws_bind, new System.ServiceModel.EndpointAddress(" +
                            (dot_net_registry_url == null ? "\"" + dot_net_default_url + "\"" : "ws_url") +
                            "));\n");
        }
        write(file,
                "        }\n\n" +
                        "        public " + dotnet_client_pck.class_name +
                        "(string endpointConfigurationName) " +
                        ": base(endpointConfigurationName)\n" +
                        "        {\n" +
                        "        }\n\n" +
                        "        public " + dotnet_client_pck.class_name +
                        "(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) " +
                        ": base(binding, remoteAddress)\n" +
                        "        {\n" +
                        "        }\n");
        for (Method meth : methods) {
            write(file, "\n" + "        public ");
            write(file, meth.return_class == null ?
                    (meth.return_prop == null ? "void" : meth.return_prop.nRealType())
                    :
                    meth.dotNetReturnClass());
            write(file, " " + meth.name + "(");
            meth.writeNetTypedList(true);
            write(file, ")\n" +
                    "        {\n");
            int indent = 12;
            if (meth.dotnet_embed_rule != null && meth.dotnet_embed_rule.before != null) {
                for (int q = 0; q < meth.dotnet_embed_rule.before.length(); q++) {
                    char c = meth.dotnet_embed_rule.before.charAt(q);
                    if (c == '{') indent += 4;
                    else if (c == '}') indent -= 4;
                }
                write(file, meth.dotnet_embed_rule.before);
            } else if (meth.execptions.length > 0) {
                write(file, "            try\n" +
                        "            {\n");
                indent += 4;
            }
            StringBuilder added_indent = new StringBuilder();
            for (int q = 0; q < indent; q++) {
                added_indent.append(' ');
            }
            write(file, added_indent.toString());
            if (!meth.filteredParameters(true).isEmpty()) {
                if (meth.return_class != null && meth.return_class.null_value != null) {
                    write(file, meth.getNetWrapper(false) + " _res = ");
                } else {
                    write(file, "return ");
                }
            }
            write(file, "base.Channel." + meth.name + "(new " + meth.getNetWrapper(true) + "(");
            next = false;
            StringBuilder spaces = new StringBuilder(",\n");
            for (int i = 0; i < position; i++) {
                spaces.append(' ');
            }
            for (Property prop : meth.filteredParameters(false)) {
                if (next) {
                    write(file, spaces.toString());
                } else {
                    next = true;
                }
                if (prop.dotnet_suppress_rule == null) {
                    write(file, prop.nPrefix() + prop.nArgument("", true));
                } else {
                    write(file, prop.dotnet_suppress_rule.header_code);
                }
            }
            write(file, "))");
            if (meth.return_class == null) {
                for (Property prop : meth.parameters) {
                    if (prop.output_mode) {
                        bad("Not Implemented Yet! Method=" + meth.name);
                        write(file, added_indent + prop.nName(true) + " = " + prop.nArgument("_res._", false) + ";\n");
                    }
                }
                if (meth.return_prop != null) {
                    write(file, meth.return_prop.nArgument("._", false));
                }
                write(file, ";\n");
            } else {
                write(file, ";\n");
                if (meth.return_class.null_value != null) {
                    write(file, added_indent + "return _res._" + meth.return_prop.name + " == " + meth.return_class.null_value + " ? null : _res;\n");
                }
            }
            if (meth.dotnet_embed_rule != null && meth.dotnet_embed_rule.after != null) {
                write(file, meth.dotnet_embed_rule.after);
            } else if (meth.execptions.length > 0) {
                write(file, "            }\n");
                for (String exn : meth.execptions) {
                    write(file, "            catch (System.ServiceModel.FaultException<_" + exn + "> e)\n" +
                            "            {\n" +
                            "                throw new " + exn + "(e);\n" +
                            "            }\n");
                }
            }
            write(file, "        }\n");
        }
        writeln(file, "    }\n}");
        close(dotnet_client_pck);
    }

    void writeDotNetConstants(FileOutputStream file, LinkedHashMap<String, Constant> constants) throws IOException {
        if (constants != null) for (String constant : constants.keySet()) {
            Constant tv = constants.get(constant);
            write(file, "\n" +
                    "        public const " + tv.type.csname + " " + constant +
                    " = " + (tv.type.enum_name.equals("string") ? "\"" : "") + tv.value + (tv.type.enum_name.equals("string") ? "\"" : "") + ";\n");
        }
    }

    void close(Package pck) throws IOException {
        close(pck.jfile);
    }

    void addImport(String string) {
        jimports.add(string);
    }

    void javaHeader(Package pck) throws IOException {
        if (pck == null) return;
        FileOutputStream jfile = pck.jfile;
        pck.writePackage();
        pck.writeImports();
        write(jfile, "\n" + pck.class_header);
        if (pck.jserver_support_code.length() > 0) {
            pck.next = true;
        }
        write(jfile, "@WebService(serviceName=\"" + service_name + "\",\n" + "            targetNamespace=\"" + tns + "\"" + pck.decoration() + ")\npublic " + pck.class_interface() + " " + pck.class_name + "\n  {\n" + pck.jserver_support_code);
    }

    void javaTerminate(Package pck) throws IOException {
        if (pck != null) {
            if (add_main) {
                writeln(pck.jfile, "\n" +
                        "    public static void main (String[] args)\n" +
                        "      {\n" +
                        "        if (args.length != 1)\n" +
                        "          {\n" +
                        "            System.out.println (\"Missing URL\");\n" +
                        "          }\n" +
                        "        Endpoint endpoint = Endpoint.create (new " + pck.class_name + " ());\n" +
                        "        endpoint.publish (args[0]);\n" +
                        "      }");
            }
            write(pck.jfile, "  }\n");
            close(pck);
        }

    }

    void javaMethod(Package pck, Method meth) throws IOException {
        if (pck == null) return;
        FileOutputStream jfile = pck.jfile;
        if (pck.next) {
            write(jfile, "\n");
        }
        pck.next = true;
        writeln(jfile, "    @WebMethod(operationName=\"" + meth.getXMLName() + "\")\n" + "    @RequestWrapper(localName=\"" + meth.getXMLName() + "\", targetNamespace=\"" + tns + "\")\n" + "    @ResponseWrapper(localName=\"" + meth.getXMLResponseName() + "\", targetNamespace=\"" + tns + "\")");
        int indent = 4;
        if (meth.return_prop == null) {
            write(jfile, "    public void");
        } else {
            write(jfile, "    @WebResult(name=\"" + meth.return_prop.getXMLName() + sub_target_ns + ")\n    public ");
            write(jfile, meth.return_prop.jName(false));
            indent = meth.return_prop.jName(false).length();
        }
        write(jfile, " " + meth.name + " (");
        indent += meth.name.length();
        boolean next = false;
        for (Property prop : meth.parameters) {
            if (next) {
                writeln(jfile, ",");
                for (int i = -14; i < indent; i++) {
                    write(jfile, " ");
                }
            }
            writeln(jfile, "@WebParam(name=\"" + prop.getXMLName() + sub_target_ns +
                    (prop.output_mode ? ", mode=WebParam.Mode." + (prop.input_mode ? "INOUT" : "OUT") : "") + ")");
            for (int i = -14; i < indent; i++) {
                write(jfile, " ");
            }
            write(jfile, (prop.output_mode ? "Holder<" + prop.jName(true) + ">" : prop.jName(false)) + " " + prop.name);
            next = true;
        }
        write(jfile, ")");
        next = false;
        for (String ex : meth.execptions) {
            if (next) {
                write(jfile, ", ");
            } else {
                next = true;
                write(jfile, "\n    throws ");
            }
            write(jfile, exceptions.get(ex).getName());
        }
        write(jfile, meth.code + "\n");
    }

    void open(Package pck, boolean java) throws IOException {
        if (pck != null) {
            new File(pck.path).mkdirs();
            pck.jfile = new FileOutputStream(pck.path + File.separatorChar + pck.class_name + (java ? ".java" : ".cs"));
        }
    }

    void open(CppPackage pck, boolean body) throws IOException {
        if (pck != null) {
            new File(pck.path).mkdirs();
            pck.jfile = new FileOutputStream(pck.path + File.separatorChar + pck.class_name + (body ? ".cpp" : ".h"));
        }
    }

    void writeWSDLProperties(String element_name, Collection<Property> properties, boolean unqualified) throws IOException {
        write(wsdl_file, "      <xs:element name=\"" + element_name + "\"");
        if (properties.size() == 0) {
            write(wsdl_file, "/");
        } else {
            write(wsdl_file, ">\n" +
                    "        <xs:complexType>\n" +
                    "          <xs:sequence>\n");
            for (Property property : properties) {
                write(wsdl_file, "            <xs:element name=\"" + property.getXMLName() + "\" type=\"" +
                        property.data_type.xsd_name + "\"" + (unqualified ? " form=\"unqualified\"" : "") +
                        (property.nullable ? (!property.listtype ? " nillable=\"true\"" : "") + " minOccurs=\"0\"" : "") +
                        (property.listtype ? " maxOccurs=\"unbounded\"" : "") + "/>\n");
            }
            write(wsdl_file, "          </xs:sequence>\n" +
                    "        </xs:complexType>\n" +
                    "      </xs:element");
        }
        writeln(wsdl_file, ">");
    }

    Property getPropertyConditional(DOMReaderHelper rd, String property) throws IOException {
        if (rd.hasNext(property)) {
            rd.getNext();
            Property prop = new Property();
            prop.name = attr.getStringConditional("Name", "return");
            String mode = attr.getStringConditional("Mode", "out");
            prop.input_mode = !mode.equals("out");
            prop.output_mode = !mode.equals("in");
            prop.xml_name = attr.getStringConditional("XMLName");
            prop.data_type = getDataType(attr.getString("Type"));
            prop.nullable = attr.getBoolean("Null");
            if (prop.listtype = attr.getBoolean("List")) {
                addImport("java.util.List");
            }
            String rewrite_rule = attr.getStringConditional("RewriteRule");
            if (rewrite_rule != null) {
                RewriteRule dnr = dotnet_rewrite_rules.get(rewrite_rule);
                if (dnr == null) {
                    bad("Unknown .NET rewrite rule: " + rewrite_rule);
                }
                prop.dotnet_rewrite_rule = dnr;
            }
            String suppress_rule = attr.getStringConditional("SuppressRule");
            if (suppress_rule != null) {
                SuppressRule dnr = dotnet_suppress_rules.get(suppress_rule);
                if (dnr == null) {
                    bad("Unknown .NET suppress rule: " + suppress_rule);
                }
                prop.dotnet_suppress_rule = dnr;
            }
            return prop;
        }
        return null;
    }

    Collection<Property> getProperties(DOMReaderHelper rd, String property) throws IOException {
        LinkedHashMap<String, Property> props = new LinkedHashMap<>();
        while (rd.hasNext(property)) {
            Property prop = getPropertyConditional(rd, property);
            if (props.put(prop.name, prop) != null) {
                bad("Duplicate property: " + prop.name);
            }
        }
        return props.values();
    }

    void bad(String string) throws IOException {
        throw new IOException(string);
    }

    void close(FileOutputStream file) throws IOException {
        position = 0;
        if (file != null) file.close();
    }

    void write(FileOutputStream file, String data) throws IOException {
        for (char c : data.toCharArray()) {
            position++;
            if (c == '\n') position = 0;
        }
        if (file != null) {
            file.write(data.getBytes("UTF-8"));
        }
    }

    void writeln(FileOutputStream file, String data) throws IOException {
        write(file, data + "\n");
    }

    @Override
    protected void toXML(DOMWriterHelper ws) throws IOException {
        // TODO Auto-generated method stub
    }

    @Override
    public String namespace() {
        return "http://xmlns.webpki.org/wscreator.1.00";
    }

    @Override
    public String element() {
        return "WebService";
    }

    static void show() {
        System.out.println(WSCreator.class.getName() + " '" + JCLIENT + "'|'" +
                JSERVER + "'|'" +
                WSDL + "'|'" +
                DOTNETCLIENT + "'|'" +
                CPPCLIENT + "'|'" +
                DOTNETDOC + "' input-file output-directory\n" + "Note: output-directory is actually file-name for the '" + WSDL + "' and '" + DOTNETDOC + "' options");
        System.exit(3);
    }

    public static void main(String args[]) {
        if (args.length != 3) show();
        if (args[0].equals(JCLIENT)) jclient = true;
        else if (args[0].equals(JSERVER)) jserver = true;
        else if (args[0].equals(WSDL)) wsdl_gen = true;
        else if (args[0].equals(DOTNETCLIENT)) dotnet_gen = true;
        else if (args[0].equals(CPPCLIENT)) cpp_gen = true;
        else if (args[0].equals(DOTNETDOC)) dotnet_doc = true;
        else
            show();
        output_directory = args[2];
        try {
            XMLSchemaCache xsc = new XMLSchemaCache();
            xsc.addWrapper(WSCreator.class);
            xsc.parse(IO.readFile(args[1]));
        } catch (IOException iox) {
            iox.printStackTrace();
            System.exit(3);
        }
    }

}
