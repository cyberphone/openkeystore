<body>
<h2>CBOR - Encoder, Decoder, Signatures, and Encryption</h2>
This package contains Java support for CBOR 
[<a href='https://www.rfc-editor.org/rfc/rfc8949.html'>RFC&nbsp;8949</a>].
<h3 id='supported-primitives'>Supported Primitives</h3>
The following table shows the currently supported CBOR
primitives and their mapping to Java:
<div class='webpkifloat'>
<table class='webpkitable' style='margin-left:2em'>
<tr><th>CBOR&nbsp;Primitive</th><th>Notes</th><th>Java&nbsp;Mapping</th>
<th>Implementation</th></tr>
<tr><td><code>integer</code></td><td>1</td><td><code>long</code></td><td>{@link CBORInteger}</td></tr>
<tr><td><code>big&nbsp;integer</code></td><td>1, 2</td><td><code>BigInteger</code></td><td>{@link CBORBigInteger}</td></tr>
<tr><td><code>floating&nbsp;point</code></td><td>3</td><td><code>double</code></td><td>{@link CBORFloatingPoint}</td></tr>
<tr><td><code>byte&nbsp;string</code></td><td></td><td><code>byte[]</code></td><td>{@link CBORBytes}</td></tr>
<tr><td><code>text&nbsp;string</code></td><td></td><td><code>String</code></td><td>{@link CBORString}</td></tr>
<tr><td><code>true</code></td><td></td><td><code>boolean</code></td><td>{@link CBORBoolean}</td></tr>
<tr><td><code>false</code></td><td></td><td><code>boolean</code></td><td>{@link CBORBoolean}</td></tr>
<tr><td><code>null</code></td><td></td><td><code>null</code></td><td>{@link CBORNull}</td></tr>
</table>
</div>
1] The distinction between unsigned and negative values is dealt with automatically.<br>
2] <code>big&nbsp;integer</code> is in this implementation identical to "<code>Bignums</code>" in the RFC.<br>
3] Floating point data covers the 16, 32, and 64-bit IEEE&nbsp;754 variants.
<p>
In addition to the primitives above, this implementation also supports
arbitrary tagged objects based on CBOR major type 6 ({@link CBORTag}).
</p>
<h3 id='deterministic-serialization'>Deterministic Serialization</h3>
In some security related applications, "raw" CBOR data is subjected
to cryptographic operations like hashing and signatures.
To make this possible without additional processing,
data must be in a stable form "on&nbsp;the&nbsp;wire".
This can either be achieved by using the binary "as&nbsp;is", or through
deterministic serialization.
This section describes a variant of latter, making compliant CBOR systems
less dependent on specific encoder and decoder designs.
Deterministic serialization also makes comparisons easier since they can
be performed at the binary level.
<div style='margin-top:0.7em'>
It is in this context worth noting that XML and JSON do not support
deterministic serialization.
</div>
<div id='standards-proposal' class='webpkicomment' style='margin:1.5em 0'>
Although APIs may be quite different compared to the API of this package,
the deterministic serialization scheme described here
is intended as a <i>standard</i>, not limited to specific platforms.
</div>
<div id='adoption-criterion'>
To facilitate mainstream adoption, the serialization scheme is aligned with
current best practices for serializing CBOR primitives and should
with moderate efforts work with most existing CBOR encoders and decoders.
In fact, having a <i>single</i> way of representing CBOR data
should simplify both implementations and associated testing.
The serialization scheme has been verified to also be usable in highly
constrained systems, albeit requiring detailed knowledge of how
a specific tool addresses serialization of CBOR objects.
Note that a compliant implementation does not have to support all CBOR primitives,
it is sufficient that the ones that actually are used by the associated applications,
conform to this specification.
</div>
<div style='margin-top:0.8em'>
The serialization scheme adheres to section 4.2 of RFC&nbsp;8949, but adds
a few constraints (denoted by RFC+), where the RFC offers choices.
The serialization rules are as follows:
</div>
<ul>
<li id='integer-serialization' class='webpkilistspacing'>
  RFC: Integers, represented by the <code>integer</code> and 
<code>big&nbsp;integer</code> types, <b>must</b> use the <code>integer</code>
type if the value is between -2^64 and 2^64-1, otherwise the
<code>big&nbsp;integer</code> type <b>must</b> be used.
The following table holds a few sample values and their proper CBOR encoding:
<div class='webpkifloat'>
<table class='webpkitable' style='margin-left:2em'>
<tr><th>Value</th><th>Encoding</th></tr>
<tr style='text-align:right'><td><code>0</code></td><td><code>00</code></td></tr>
<tr style='text-align:right'><td><code>-1</code></td><td><code>20</code></td></tr>
<tr style='text-align:right'><td><code>255</code></td><td><code>18ff</code></td></tr>
<tr style='text-align:right'><td><code>256</code></td><td><code>190100</code></td></tr>
<tr style='text-align:right'><td><code>-256</code></td><td><code>38ff</code></td></tr>
<tr style='text-align:right'><td><code>-257</code></td><td><code>390100</code></td></tr>
<tr style='text-align:right'><td><code>1099511627775</code></td><td><code>1b000000ffffffffff</code></td></tr>
<tr style='text-align:right'><td><code>18446744073709551615</code></td><td><code>1bffffffffffffffff</code></td></tr>
<tr style='text-align:right'><td><code>18446744073709551616</code></td><td><code>c249010000000000000000</code></td></tr>
</table>
</div>
Note that integers <b>must not</b> be supplied with 
<i>leading zero bytes</i> (like <code>1900ff</code>) unless the
CBOR representation offers no alternative (like <code>1b000000ffffffffff</code>).
<div style='margin:0.7em 0 0.3em 0'>
Note that the integer serialization scheme above does not always return the
most compact representation; the value 
<code>1099511627775</code> 
(<code>0xffffffffff</code>)
would actually yield two bytes less using the <code>big&nbsp;integer</code> type. 
</div>
</li>
<li id='floating-point-serialization' class='webpkilistspacing'>
  RFC+: Floating point data <b>must</b> use the shortest IEEE&nbsp;754
  variant and associated CBOR encoding.
The following table holds floating point values needing special considerations
as well as a small set of "edge&nbsp;cases":
<div class='webpkifloat'>
<table class='webpkitable' style='margin-left:2em'>
<tr><th>Value</th><th>Encoding</th></tr>
<tr style='text-align:right'><td><code>0.0</code></td><td><code>f90000</code></td></tr>
<tr style='text-align:right'><td><code>-0.0</code></td><td><code>f98000</code></td></tr>
<tr style='text-align:right'><td><code>Infinity</code></td><td><code>f97c00</code></td></tr>
<tr style='text-align:right'><td><code>-Infinity</code></td><td><code>f9fc00</code></td></tr>
<tr style='text-align:right'><td><code>NaN</code></td><td><code>f97e00</code></td></tr>
<tr><th colspan='2'>Assorted Edge Cases</th></tr>
<tr style='text-align:right'><td><code>-5.9604644775390625e-8</code></td><td><code>f98001</code></td></tr>
<tr style='text-align:right'><td><code>-5.960465188081798e-8</code></td><td><code>fab3800001</code></td></tr>
<tr style='text-align:right'><td><code>65504.0</code></td><td><code>f97bff</code></td></tr>
<tr style='text-align:right'><td><code>65504.00390625</code></td><td><code>fa477fe001</code></td></tr>
<tr style='text-align:right'><td><code>65536.0</code></td><td><code>fa47800000</code></td></tr>
<tr style='text-align:right'><td><code>10.559998512268066</code></td><td><code>fa4128f5c1</code></td></tr>
<tr style='text-align:right'><td><code>10.559999942779541</code></td><td><code>fb40251eb850000000</code></td></tr>
<tr style='text-align:right'><td><code>3.4028234663852886e+38</code></td><td><code>fa7f7fffff</code></td></tr>
<tr style='text-align:right'><td><code>3.402823466385289e+38</code></td><td><code>fb47efffffe0000001</code></td></tr>
<tr style='text-align:right'><td><code>5.0e-324</code></td><td><code>fb0000000000000001</code></td></tr>
<tr style='text-align:right'><td><code>-1.7976931348623157e+308</code></td><td><code>fbffefffffffffffff</code></td></tr>
</table>
</div>
Note that <code>NaN</code> "signaling" (like <code>f97e01</code>),
<b>must</b> be flagged as an <i>error</i>.
<div style='margin:0.7em 0 0.3em 0'>
Note that the shortest encoding may result in <i>subnormal</i>
numbers like <code>f98001</code>.
</div>
<li id='number-serialization' class='webpkilistspacing'>
  RFC+: Floating point and integer objects <b>must</b> be treated as <i>distinct types</i>
regardless of their numeric value, which is compliant with
Rule&nbsp;2 in section 4.2.2 as well
as with the table in Appendix&nbsp;A of RFC&nbsp;8949.</li>
<li class='webpkilistspacing'>
  RFC: Map keys <b>must</b> be sorted in the bytewise lexicographic 
order of their deterministic encoding.
Duplicate keys <b>must</b> be rejected.
</li>
<li id='map-key-equivalence'>
  RFC+: Since CBOR encoding according to this specification
maintains CBOR type uniqueness, there are no specific restrictions or
tests needed in order to determine map key equivalence.  
As an example, the floating point numbers <code>0.0</code> and
<code>-0.0</code>, and the integer number <code>0</code>
represent the distinct keys
<code>f90000</code>, <code>f98000</code>, and <code>00</code> respectively.
</li>
</ul>
Any deviation from the rules above will throw exceptions using the standard decoder
({@link CBORObject#decode(byte[])}).
For more control of the decoding process including dealing with CBOR sequences, see:
{@link CBORObject#decode(inputStream, boolean, boolean, boolean, Integer)
CBOR&nbsp;decoding&nbsp;options}.
<p>
On output ({@link CBORObject#encode()})
deterministic serialization is always performed
regardless of if CBOR data was parsed or created programmatically.
</p>
<div id='map-key-constraints' class='webpkicomment' style='margin-bottom:0.3em'>
For maximum interoperability with <i>other</i> CBOR implementations,
map key types <b>should</b> be limited to <code>integer</code> and
<code>text&nbsp;string</code>,
as well as not being mixed in the same map.
</div>
<h3 id='input-data-validation'>Input Data Validation</h3>
A properly designed system validates input data before acting upon it.
This section describes how this can be achieved using this particular
CBOR implementation.
<p>
During {@link CBORObject#decode(byte[])}, CBOR data is checked for
well-formedness as well as by default, adhering to the determinism scheme.
</p>
<p>
After successful decoding, the CBOR data is provided as a {@link CBORObject}.
For extracting the data of CBOR primitives in a Java compatible way,
access methods such as 
{@link CBORObject#getInt()} and {@link CBORObject#getString()}
must be used.
Structured CBOR objects must be accessed
through methods such as {@link CBORObject#getMap()} and
{@link CBORObject#getArray()},
returning container objects which in turn facilitate
access to individual CBOR objects of the structure.
</p>
<p>
If the underlying CBOR data type does not match the access method
(like performing {@link CBORObject#getInt()} on a {@link CBORBigInteger}),
an exception is thrown.
That is, this implementation performs <i>strict type checking</i>. 
However, you typically also want to verify
that {@link CBORMap} objects do not contain unexpected keys,
or that {@link CBORArray} objects contain unread elements.
This can be achieved by calling {@link CBORObject#checkForUnread()},
<i>after</i> all expected objects have been read.
This method verifies that the current CBOR object (including
possible child objects), have been accessed, otherwise
an exception will be thrown.
</p>
<p>
Built-in cryptographic support classes like {@link CBORValidator}
and {@link CBORPublicKey} perform strict type checking
as well as verifying that there are no unexpected objects
inside of their respective containers.
</p>
<h3 id='cryptographic-support'>Cryptographic Support</h3>
To aid the use of cryptography, support for
<a href='doc-files/signatures.html'>signatures</a> and 
<a href='doc-files/encryption.html'>encryption</a> is integrated in the package.
<h3 id='diagnostic-cbor'>Diagnostic CBOR</h3>
Through the {@link CBORDiagnosticParser} class, CBOR in diagnostic (textual) notation 
may also be processed. 
</body>
