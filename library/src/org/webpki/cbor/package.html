<body>
<h2>CBOR - Encoder, Decoder, Signatures, and Encryption</h2>
This package contains Java support for CBOR 
[<a href='https://www.rfc-editor.org/rfc/rfc8949.html'>RFC&nbsp;8949</a>].
<h3 id='supported-primitives'>Supported Primitives</h3>
<table class='webpkitable'>
<tr><th>CBOR Data Type</th><th>Notes</th><th>Java&nbsp;Mapping</th>
<th>Implementation</th></tr>
<tr><td><code>integer</code></td><td>1</td><td><code>long</code></td><td>{@link CBORInteger}</td></tr>
<tr><td><code>big integer</code></td><td>1, 2</td><td><code>BigInteger</code></td><td>{@link CBORBigInteger}</td></tr>
<tr><td><code>floating point</code></td><td>3</td><td><code>double</code></td><td>{@link CBORFloatingPoint}</td></tr>
<tr><td><code>byte string</code></td><td></td><td><code>byte[]</code></td><td>{@link CBORByteString}</td></tr>
<tr><td><code>text string</code></td><td></td><td><code>String</code></td><td>{@link CBORTextString}</td></tr>
<tr><td><code>true</code></td><td></td><td><code>boolean</code></td><td>{@link CBORBoolean}</td></tr>
<tr><td><code>false</code></td><td></td><td><code>boolean</code></td><td>{@link CBORBoolean}</td></tr>
<tr><td><code>null</code></td><td></td><td><code>null</code></td><td>{@link CBORNull}</td></tr>
</table>
<p>1] The distinction between unsigned and negative values is dealt with automatically.<br>
2] <code>big integer</code> is in this implementation identical to "<code>Bignums</code>" in the RFC.<br>
3] Floating point data covers the 16, 32, and 64-bit IEEE 754 variants.</p>
<p>
In addition to the primitives above, this implementation also supports
arbitrary tagged objects based on CBOR major type 6 ({@link CBORTag}).
</p>
<h3 id='deterministic-serialization'>Deterministic Serialization</h3>
This package is also intended to be used for security related
applications where "raw" CBOR data is subjected to cryptographic operations
like hashing and signatures.
To make this possible without additional processing,
data must be in a stable form "on the wire".
This can either be achieved by using the binary "as is", or through
deterministic serialization.
This section describes a variant of latter, making compliant CBOR systems
less dependent on specific encoder and decoder designs.
Deterministic serialization also makes comparisons easier since they can
be performed at the binary level.
<div style='margin-top:0.7em'>
It is in this context worth noting that XML and JSON do not support
deterministic serialization.
</div>
<div id='standards-proposal' class='webpkicomment'>
Although APIs may be quite different,
the deterministic serialization scheme described here
is intended as a <i>standard</i>,
not in any way limited to the Java platform.
</div>
<div id='adoption-criterion'>
To facilitate mainstream adoption, the serialization scheme is
deliberately rather conservative, and should with
moderate efforts work with most existing CBOR encoders and decoders.
</div>
<div style='margin-top:0.8em'>
The serialization scheme adhere to section 4.2 of RFC&nbsp;8949, but adds
a few constraints (denoted by RFC+), where the RFC offers choices.
The serialization rules are as follows:
</div>
<ul>
<li id='integer-serialization' class='webpkilistspacing'>
  RFC: Integers, represented by the <code>integer</code> and 
<code>big&nbsp;integer</code> types, <b>must</b> use the <code>integer</code>
type if the value is between -2^64 and 2^64-1, otherwise the
<code>big&nbsp;integer</code> type <b>must</b> be used.
The following table holds a few sample values and their proper CBOR encoding:
<table class='webpkitable' style='margin:0.7em 0 0.7em 2em'>
<tr><th>Value</th><th>Encoding</th></tr>
<tr style='text-align:right'><td><code>0</code></td><td><code>00</code></td></tr>
<tr style='text-align:right'><td><code>-1</code></td><td><code>20</code></td></tr>
<tr style='text-align:right'><td><code>255</code></td><td><code>18ff</code></td></tr>
<tr style='text-align:right'><td><code>256</code></td><td><code>190100</code></td></tr>
<tr style='text-align:right'><td><code>-256</code></td><td><code>38ff</code></td></tr>
<tr style='text-align:right'><td><code>-257</code></td><td><code>390100</code></td></tr>
<tr style='text-align:right'><td><code>1099511627775</code></td><td><code>1b000000ffffffffff</code></td></tr>
<tr style='text-align:right'><td><code>18446744073709551615</code></td><td><code>1bffffffffffffffff</code></td></tr>
<tr style='text-align:right'><td><code>18446744073709551616</code></td><td><code>c249010000000000000000</code></td></tr>
</table>
Note that integers <b>must not</b> be supplied with 
<i>leading zero bytes</i> (like <code>1900ff</code>) unless the
CBOR representation offers no alternative (like <code>1b000000ffffffffff</code>).
<div style='margin:0.7em 0 0.3em 0'>
Note that the integer serialization scheme above does not always return the
most compact representation; the value 
<code>1099511627775</code> 
(<code>0xffffffffff</code>)
would actually yield two bytes less using the <code>big&nbsp;integer</code> type. 
</div>
</li>
<li id='floating-point-serialization' class='webpkilistspacing'>
  RFC+: Floating point data <b>must</b> use the shortest variant
including the following special values and their proper CBOR encoding:
<table class='webpkitable' style='margin:0.7em 0 0.7em 2em'>
<tr><th>Value</th><th>Encoding</th></tr>
<tr style='text-align:right'><td><code>0.0</code></td><td><code>f90000</code></td></tr>
<tr style='text-align:right'><td><code>-0.0</code></td><td><code>f98000</code></td></tr>
<tr style='text-align:right'><td><code>Infinity</code></td><td><code>f97c00</code></td></tr>
<tr style='text-align:right'><td><code>-Infinity</code></td><td><code>f9fc00</code></td></tr>
<tr style='text-align:right'><td><code>NaN</code></td><td><code>f97e00</code></td></tr>
<tr style='text-align:right'><td><code>-5.9604644775390625e-8</code></td><td><code>f98001</code></td></tr>
<tr style='text-align:right'><td><code>-5.960465188081798e-8</code></td><td><code>fab3800001</code></td></tr>
<tr style='text-align:right'><td><code>65504.0</code></td><td><code>f97bff</code></td></tr>
<tr style='text-align:right'><td><code>65504.00390625</code></td><td><code>fa477fe001</code></td></tr>
<tr style='text-align:right'><td><code>65536.0</code></td><td><code>fa47800000</code></td></tr>
<tr style='text-align:right'><td><code>10.559998512268066</code></td><td><code>fa4128f5c1</code></td></tr>
<tr style='text-align:right'><td><code>10.559999942779541</code></td><td><code>fb40251eb850000000</code></td></tr>
<tr style='text-align:right'><td><code>3.4028234663852886e+38</code></td><td><code>fa7f7fffff</code></td></tr>
<tr style='text-align:right'><td><code>3.402823466385289e+38</code></td><td><code>fb47efffffe0000001</code></td></tr>
<tr style='text-align:right'><td><code>5.0e-324</code></td><td><code>fb0000000000000001</code></td></tr>
<tr style='text-align:right'><td><code>-1.7976931348623157e+308</code></td><td><code>fbffefffffffffffff</code></td></tr>
</table>
<div>
Note that <code>NaN</code> "signaling" (like <code>f97e01</code>),
<b>must</b> be flagged as an <i>error</i>.
</div>
<div style='margin:0.7em 0 0.3em 0'>
Note that the shortest encoding may result in <i>subnormal</i>
numbers like <code>f98001</code>.
</div>
<li id='number-serialization' class='webpkilistspacing'>
  RFC+: Floating point and integer objects <b>must</b> be treated as <i>distinct types</i>
regardless of their numeric value (Rule&nbsp;2 in section 4.2.2 of RFC&nbsp;8949).</li>
<li class='webpkilistspacing'>
  RFC: Map keys <b>must</b> be sorted in the bytewise lexicographic 
order of their deterministic encoding.
Duplicate keys <b>must</b> be rejected.
</li>
<li id='map-key-equivalence'>
  RFC+: Since CBOR encoding according to this specification
maintains CBOR type uniqueness, there are no specific restrictions or
tests needed in order to determine map key equivalence.  
As an example, the floating point numbers <code>0.0</code> and
<code>-0.0</code>, and the integer number <code>0</code>
represent the distinct keys
<code>f90000</code>, <code>f98000</code>, and <code>00</code> respectively.
<div id='map-key-constraints' style='margin:0.5em 0 0.3em 0'>
However, for maximum interoperability with <i>other</i> CBOR implementations,
map key types <b>should</b> be limited to <code>integer</code> and
<code>text&nbsp;string</code>,
as well as not being mixed in the same map.
</div>
</li>
</ul>
Any deviation from the rules above will throw
exceptions using the standard decoder
({@link CBORObject#decode(byte[])}).  See also
{@link CBORObject#decode(inputStream, boolean, boolean, boolean, Integer) CBOR decoding options}.
<p>
On output ({@link CBORObject#encode()})
deterministic serialization is always used
regardless of if CBOR data was parsed or created programmatically.
</p>
<h3 id='cryptographic-support'>Cryptographic Support</h3>
To aid the use of cryptography, support for
<a href='doc-files/signatures.html'>signatures</a> and 
<a href='doc-files/encryption.html'>encryption</a> is integrated in the package.
<h3 id='diagnostic-cbor'>Diagnostic CBOR</h3>
Through the {@link CBORDiagnosticParser} class, CBOR in diagnostic (textual) notation 
may also be processed. 
</body>
